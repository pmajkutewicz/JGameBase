/*
 * Copyright (C) 2006-2014 F. Gerbig (fgerbig@users.sourceforge.net)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package jgamebase.gui;

import static jgamebase.Const.log;

import java.awt.Cursor;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.swing.SwingWorker;

import jgamebase.Const;
import jgamebase.db.Db;
import jgamebase.db.model.Extra;
import jgamebase.db.model.Game;
import jgamebase.db.model.Item;
import jgamebase.db.model.ItemView;
import jgamebase.db.model.Music;
import jgamebase.model.Databases;
import jgamebase.model.Paths;
import jgamebase.tools.ListerTools;

/**
 * The GameBase GUI.
 * 
 * @author F. Gerbig (fgerbig@users.sourceforge.net)
 */
public class VerifyAvailableFilesDialog extends javax.swing.JDialog {

  /**
	 *
	 */
  private static final long serialVersionUID = -211835818560997806L;

  private final static int STATUS_STOPPED = 1;

  private final static int STATUS_RUNNING = 2;

  private static final String MISSING_FILE_LIST_EXTENSION = "mfl"; // Missing
                                                                   // File List

  private int status = STATUS_STOPPED;

  private File file;

  private PrintWriter out;

  public VerifyAvailableFilesDialog() {
    initComponents();
    setSize(540, 184);
    setLocationRelativeTo(null);
    try {
      setVisible(true);
    } catch (final NullPointerException npe) {
      // progress bar throws null pointer if not initialized
    }
  }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox extrasCheckBox;
    private javax.swing.JLabel extrasLabel;
    private javax.swing.JCheckBox gamesCheckBox;
    private javax.swing.JLabel gamesLabel;
    private javax.swing.JCheckBox musicCheckBox;
    private javax.swing.JLabel musicLabel;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JLabel progressLabel;
    private javax.swing.JCheckBox screenshotsCheckBox;
    private javax.swing.JLabel screenshotsLabel;
    private javax.swing.JButton startButton;
    // End of variables declaration//GEN-END:variables

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc=" Generated Code
  // <editor-fold defaultstate="collapsed" desc=" Generated Code
  // <editor-fold defaultstate="collapsed"
  // <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        javax.swing.JPanel jPanel1 = new javax.swing.JPanel();
        javax.swing.JPanel mainPanel = new javax.swing.JPanel();
        gamesCheckBox = new javax.swing.JCheckBox();
        gamesLabel = new javax.swing.JLabel();
        musicCheckBox = new javax.swing.JCheckBox();
        musicLabel = new javax.swing.JLabel();
        screenshotsCheckBox = new javax.swing.JCheckBox();
        screenshotsLabel = new javax.swing.JLabel();
        extrasCheckBox = new javax.swing.JCheckBox();
        extrasLabel = new javax.swing.JLabel();
        javax.swing.JPanel buttonPanel = new javax.swing.JPanel();
        progressLabel = new javax.swing.JLabel();
        progressBar = new javax.swing.JProgressBar();
        startButton = new javax.swing.JButton();
        javax.swing.JButton cancelButton = new javax.swing.JButton();

        setTitle("Verify Available Files...");
        setMinimumSize(new java.awt.Dimension(580, 200));
        setModal(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitFormWindowClosing(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
        jPanel1.setLayout(new java.awt.BorderLayout());

        mainPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(""));
        mainPanel.setLayout(new java.awt.GridBagLayout());

        gamesCheckBox.setSelected(true);
        gamesCheckBox.setText("Games");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        mainPanel.add(gamesCheckBox, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        mainPanel.add(gamesLabel, gridBagConstraints);

        musicCheckBox.setSelected(true);
        musicCheckBox.setText("Music");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        mainPanel.add(musicCheckBox, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        mainPanel.add(musicLabel, gridBagConstraints);

        screenshotsCheckBox.setSelected(true);
        screenshotsCheckBox.setText("Screenshots");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        mainPanel.add(screenshotsCheckBox, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        mainPanel.add(screenshotsLabel, gridBagConstraints);

        extrasCheckBox.setSelected(true);
        extrasCheckBox.setText("Extras");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        mainPanel.add(extrasCheckBox, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        mainPanel.add(extrasLabel, gridBagConstraints);

        jPanel1.add(mainPanel, java.awt.BorderLayout.CENTER);

        getContentPane().add(jPanel1, java.awt.BorderLayout.NORTH);

        buttonPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));
        buttonPanel.setLayout(new java.awt.GridBagLayout());

        progressLabel.setText(" ");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        buttonPanel.add(progressLabel, gridBagConstraints);

        progressBar.setStringPainted(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        buttonPanel.add(progressBar, gridBagConstraints);

        startButton.setMnemonic('O');
        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        buttonPanel.add(startButton, gridBagConstraints);

        cancelButton.setMnemonic('C');
        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        buttonPanel.add(cancelButton, gridBagConstraints);

        getContentPane().add(buttonPanel, java.awt.BorderLayout.SOUTH);

        pack();
    }// </editor-fold>//GEN-END:initComponents

  private void cancelActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_cancelActionPerformed
    cancel();
  }// GEN-LAST:event_cancelActionPerformed

  private void cancel() {
    if (status == STATUS_STOPPED) {
      dispose();
    }

    status = STATUS_STOPPED;
    startButton.setVisible(true);
  }

  private void startActionPerformed(final java.awt.event.ActionEvent evt) {// GEN-FIRST:event_startActionPerformed
    new SwingWorker<Void, Void>() {

      @Override
      protected Void doInBackground() throws Exception {

        status = STATUS_RUNNING;
        startButton.setVisible(false);
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

        try {
          file = new File(Databases.getCurrent().getPath(), "VerifyAvailableFiles.log");
          out = new PrintWriter(new FileWriter(file));

          out.println(new SimpleDateFormat("EEEE dd MMMM yyyy HH:mm:ss").format(new Date()));
          out.println();
          out.println("DATABASE PATH");
          out.println("  " + Databases.getCurrent().getPath());
          out.println();
          out.println();

          if (gamesCheckBox.isSelected() && (status == STATUS_RUNNING)) {
            verifyGames();
          }

          if (musicCheckBox.isSelected() && (status == STATUS_RUNNING)) {
            verifyMusic();
          }

          if (screenshotsCheckBox.isSelected() && (status == STATUS_RUNNING)) {
            verifyScreenshots();
          }

          if (extrasCheckBox.isSelected() && (status == STATUS_RUNNING)) {
            verifyExtras();
          }

        } catch (final IOException e) {
          e.printStackTrace();
        } finally {
          if (out != null) {
            out.close();
          }
          status = STATUS_STOPPED;
          startButton.setVisible(true);
          setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }
        return null;
      }

      @Override
      protected void done() {
        status = STATUS_STOPPED;
        startButton.setVisible(true);
        setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
      }

    }.execute();
  }// GEN-LAST:event_startActionPerformed

  private void verifyGames() {
    final File missingFileList = new File(
        new File(Const.GBDIR_RW, Databases.getCurrent().getName()), "games."
            + MISSING_FILE_LIST_EXTENSION);
    PrintWriter missing = null;

    missingFileList.delete(); // delete old "missing file list"
    status = STATUS_RUNNING;

    List<Item> list;
    final List<Game> notFound = new ArrayList<Game>();

    // init
    gamesLabel.setText("");
    progressBar.setIndeterminate(true);
    progressBar.setMinimum(0);
    progressBar.setValue(0);
    out.println("VERIFY GAMES");
    out.println("Paths:");
    for (final String path : ListerTools.fileListToStringList(Paths.getGamePath().getWithDefault())) {
      out.println("  " + path);
    }
    out.println();

    // read items into list
    progressLabel.setText("Loading games...");
    final ItemView view = new ItemView();
    view.setInclude(ItemView.INCLUDE_GAMES);
    list = Db.getItems(view);
    final int completeListSize = list.size();

    gamesLabel.setText(list.size() + " games loaded.");
    // remove games without game file
    for (final Iterator<?> iter = list.iterator(); iter.hasNext();) {
      final Game game = (Game) iter.next();
      if (game.getFilename().isEmpty()) {
        iter.remove();
      }
    }

    // start working
    gamesLabel.setText("Searching for " + list.size() + " of " + completeListSize + " games.");
    progressBar.setIndeterminate(false);
    progressLabel.setText("Verifying games...");
    progressBar.setMaximum(list.size() - 1);

    try {
      missing = new PrintWriter(missingFileList);

      int i = 0;
      for (final Item item : list) {
        final Game game = (Game) item;
        progressBar.setValue(i);
        progressLabel.setText("Verifying games... " + i + "/" + list.size());

        // setting the filename converts backslashes and removes trailing spaces
        game.setFilename(game.getFilename());

        boolean found = Paths.getGamePath().exists(new File(game.getFilename()));
        if (!found) { // search case insensitive
          final String correctFilename = Paths.getGamePath().findCorrectFilename(
              new File(game.getFilename()));
          found = (correctFilename != null);

          if (found) {
            log.warn("Game: correcting filename case '" + game.getFilename() + "' to '"
                + correctFilename + "'");
            game.setFilename(correctFilename);
          }
        }
        game.setGameFileExists(found);

        if (!found) {
          // if no file was found add the item to a new list
          notFound.add(game);
          missing.println(game.getFilename());
          missing.flush();
        }

        if (status == STATUS_STOPPED) {
          break;
        }
        i++;
      }
    } catch (final IOException ioe) {
      ioe.printStackTrace();
    } finally {
      if (missing != null) {
        missing.close();
      }
    }

    gamesLabel.setText("Games not found: " + notFound.size() + "/" + list.size()
        + " specifying a game file of " + completeListSize + " total");

    out.println("Games not found: " + notFound.size() + "/" + list.size());
    for (final Game game : notFound) {
      out.println("   " + game.getFilename() + "  (" + game.getName() + ")");
    }
    out.println();
    out.println();
    out.println();

    progressBar.setIndeterminate(true);
    progressLabel.setText("Writing to database...");
    Db.saveOrUpdateAll(list);

    // clean up
    progressBar.setIndeterminate(false);
    progressLabel.setText(" ");
    progressBar.setMinimum(0);
    progressBar.setValue(0);
  }

  private void verifyMusic() {
    final File missingFileList = new File(
        new File(Const.GBDIR_RW, Databases.getCurrent().getName()), "music."
            + MISSING_FILE_LIST_EXTENSION);
    PrintWriter missing = null;

    missingFileList.delete(); // delete old "missing file list"
    status = STATUS_RUNNING;

    List<Item> list;
    final List<Item> notFound = new ArrayList<Item>();

    // init
    musicLabel.setText("");
    progressBar.setIndeterminate(true);
    progressBar.setMinimum(0);
    progressBar.setValue(0);
    out.println("VERIFY MUSIC");
    out.println("Paths:");
    for (final String path : ListerTools
        .fileListToStringList(Paths.getMusicPath().getWithDefault())) {
      out.println("  " + path);
    }
    out.println();

    // read items into list
    progressLabel.setText("Loading music...");
    final ItemView view = new ItemView();
    view.setInclude(ItemView.INCLUDE_BOTH);
    list = Db.getItems(view);

    // remove items without music file
    for (final Iterator<?> iter = list.iterator(); iter.hasNext();) {
      final Item item = (Item) iter.next();
      if (((item instanceof Game) && (((Game) item).getMusicFilename().isEmpty()))
          || ((item instanceof Music) && (item.getFilename().isEmpty()))) {
        iter.remove();
      }
    }
    musicLabel.setText(list.size() + " pieces of music loaded.");

    // start working
    musicLabel.setText("Searching for " + list.size() + " pieces of music.");
    progressBar.setIndeterminate(false);
    progressLabel.setText("Verifying music...");
    progressBar.setMaximum(list.size() - 1);

    try {
      missing = new PrintWriter(missingFileList);

      int i = 0;
      for (final Item item : list) {
        progressBar.setValue(i);
        progressLabel.setText("Verifying music... " + i + "/" + list.size());

        if (item instanceof Game) {
          final Game game = (Game) item;

          // setting the filename converts backslashes and removes trailing
          // spaces
          game.setMusicFilename(game.getMusicFilename());

          boolean found = Paths.getMusicPath().exists(new File(game.getMusicFilename()));
          if (!found) { // search case insensitive
            final String correctFilename = Paths.getMusicPath().findCorrectFilename(
                new File(game.getMusicFilename()));
            found = (correctFilename != null);

            if (found) {
              log.warn("Music(Game): correcting filename case '" + game.getMusicFilename()
                  + "' to '" + correctFilename + "'");
              game.setMusicFilename(correctFilename);
            }
          }
          game.setMusicFileExists(found);

          // if no file was found add the item to a new list
          if (!found) {
            notFound.add(game);
            missing.println(game.getMusicFilename());
            missing.flush();
          }
        }

        if (item instanceof Music) {
          final Music music = (Music) item;

          // setting the filename converts backslashes and removes trailing
          // spaces
          music.setFilename(music.getFilename());

          boolean found = Paths.getMusicPath().exists(new File(music.getFilename()));
          if (!found) { // search case insensitive
            final String correctFilename = Paths.getMusicPath().findCorrectFilename(
                new File(music.getFilename()));
            found = (correctFilename != null);

            if (found) {
              log.warn("Music: correcting filename case '" + music.getFilename() + "' to '"
                  + correctFilename + "'");
              music.setFilename(correctFilename);
            }
          }
          music.setFileExists(found);

          // if no file was found add the item to a new list
          if (!found) {
            notFound.add(music);
            missing.println(music.getFilename());
            missing.flush();
          }
        }

        if (status == STATUS_STOPPED) {
          break;
        }
        i++;
      }
    } catch (final IOException ioe) {
      ioe.printStackTrace();
    } finally {
      if (missing != null) {
        missing.close();
      }
    }

    musicLabel.setText("Pieces of music not found: " + notFound.size() + "/" + list.size());

    out.println("Pieces of music not found: " + notFound.size() + "/" + list.size());
    for (final Item item : notFound) {
      String filename = "";

      if (item instanceof Game) {
        filename = ((Game) item).getMusicFilename();
      }

      if (item instanceof Music) {
        filename = item.getFilename();
      }

      out.println("   " + filename + "  (" + item.getName() + ")");
    }
    out.println();
    out.println();
    out.println();

    progressBar.setIndeterminate(true);
    progressLabel.setText("Writing to database...");
    Db.saveOrUpdateAll(list);

    // clean up
    progressBar.setIndeterminate(false);
    progressLabel.setText(" ");
    progressBar.setMinimum(0);
    progressBar.setValue(0);
  }

  private void verifyScreenshots() {
    final File missingFileList = new File(
        new File(Const.GBDIR_RW, Databases.getCurrent().getName()), "screenshots."
            + MISSING_FILE_LIST_EXTENSION);
    PrintWriter missing = null;

    missingFileList.delete(); // delete old "missing file list"
    status = STATUS_RUNNING;

    List<Item> list;
    final List<Game> notFound = new ArrayList<Game>();

    // init
    screenshotsLabel.setText("");
    progressBar.setIndeterminate(true);
    progressBar.setMinimum(0);
    progressBar.setValue(0);
    out.println("VERIFY SCREENSHOTS");
    out.println("Paths:");
    for (final String path : ListerTools.fileListToStringList(Paths.getScreenshotPath()
        .getWithDefault())) {
      out.println("  " + path);
    }
    out.println();

    // read items into list
    progressLabel.setText("Loading screenshots...");
    final ItemView view = new ItemView();
    view.setInclude(ItemView.INCLUDE_GAMES);
    list = Db.getItems(view);

    // remove games without game file
    for (final Iterator<?> iter = list.iterator(); iter.hasNext();) {
      final Game game = (Game) iter.next();
      if (game.getScreenshotFilename().isEmpty()) {
        iter.remove();
      }
    }
    screenshotsLabel.setText(list.size() + " Screenshots loaded.");

    // start working
    screenshotsLabel.setText("Searching for " + list.size() + " screenshots.");
    progressBar.setIndeterminate(false);
    progressLabel.setText("Verifying screenshots...");
    progressBar.setMaximum(list.size() - 1);

    try {
      missing = new PrintWriter(missingFileList);

      int i = 0;
      for (final Item item : list) {
        final Game game = (Game) item;
        progressBar.setValue(i);

        progressLabel.setText("Verifying screenshots... " + i + "/" + list.size());

        // setting the filename converts backslashes and removes trailing spaces
        game.setScreenshotFilename(game.getScreenshotFilename());

        boolean found = Paths.getScreenshotPath().exists(new File(game.getScreenshotFilename()));
        if (!found) { // search case insensitive
          final String correctFilename = Paths.getScreenshotPath().findCorrectFilename(
              new File(game.getScreenshotFilename()));
          found = (correctFilename != null);

          if (found) {
            log.warn("Screenshot: correcting filename case '" + game.getScreenshotFilename()
                + "' to '" + correctFilename + "'");
            game.setScreenshotFilename(correctFilename);
          }
        }

        // if no file was found add the item to a new list
        if (!found) {
          notFound.add(game);
          missing.println(game.getScreenshotFilename());
          missing.flush();
        }

        if (status == STATUS_STOPPED) {
          break;
        }
        i++;
      }
    } catch (final IOException ioe) {
      ioe.printStackTrace();
    } finally {
      if (missing != null) {
        missing.close();
      }
    }

    screenshotsLabel.setText("Screenshots not found: " + notFound.size() + "/" + list.size());

    out.println("Screenshots not found: " + notFound.size() + "/" + list.size());
    for (final Game game : notFound) {
      out.println("   " + game.getScreenshotFilename() + "  (" + game.getName() + ")");
    }
    out.println();
    out.println();
    out.println();

    // clean up
    progressBar.setIndeterminate(false);
    progressLabel.setText(" ");
    progressBar.setMinimum(0);
    progressBar.setValue(0);
  }

  private void verifyExtras() {
    final File missingFileList = new File(
        new File(Const.GBDIR_RW, Databases.getCurrent().getName()), "extras."
            + MISSING_FILE_LIST_EXTENSION);
    PrintWriter missing = null;

    missingFileList.delete(); // delete old "missing file list"
    status = STATUS_RUNNING;

    List<Extra> list;
    final List<Extra> notFound = new ArrayList<Extra>();
    final List<Game> gameList = new ArrayList<Game>();

    // init
    extrasLabel.setText("");
    progressBar.setIndeterminate(true);
    progressBar.setMinimum(0);
    progressBar.setValue(0);
    out.println("VERIFY EXTRAS");
    out.println("Paths:");
    for (final String path : ListerTools
        .fileListToStringList(Paths.getExtraPath().getWithDefault())) {
      out.println("  " + path);
    }
    out.println();

    // read items into list
    progressLabel.setText("Loading extras...");
    list = Db.getExtras();
    // remove games without game file
    for (final Iterator<?> iter = list.iterator(); iter.hasNext();) {
      final Extra extra = (Extra) iter.next();
      if (extra.getFilename().isEmpty()) {
        iter.remove();
      }
    }
    extrasLabel.setText(list.size() + " Extras loaded.");

    // start working
    extrasLabel.setText("Searching for " + list.size() + " extras.");
    progressBar.setIndeterminate(false);
    progressLabel.setText("Verifying extras...");
    progressBar.setMaximum(list.size() - 1);

    try {
      missing = new PrintWriter(missingFileList);

      int i = 0;
      for (final Extra extra : list) {
        progressBar.setValue(i);
        progressLabel.setText("Verifying extras... " + i + "/" + list.size());

        // setting the filename converts backslashes and removes trailing spaces
        extra.setFilename(extra.getFilename());

        boolean found = false;

        if (extra.isUrl()) {
          // URLs are always "found"
          found = true;
        } else {
          // no URL, look for file
          found = Paths.getExtraPath().exists(new File(extra.getFilename()));
        }

        if (!found) { // search case insensitive
          final String correctFilename = Paths.getExtraPath().findCorrectFilename(
              new File(extra.getFilename()));
          found = (correctFilename != null);

          if (found) {
            log.warn("Extra: correcting filename case '" + extra.getFilename() + "' to '"
                + correctFilename + "'");
            extra.setFilename(correctFilename);
          }
        }

        // if no file was found add the item to a new list
        if (!found) {
          notFound.add(extra);
          missing.println(extra.getFilename());
          missing.flush();
        } else {
          // set game has extra
          final Game game = Db.getGameById(extra.getGameId());
          if (game != null) {
            game.setHasExtras(true);
            gameList.add(game);
          }
        }

        if (status == STATUS_STOPPED) {
          break;
        }
        i++;
      }
    } catch (final IOException ioe) {
      ioe.printStackTrace();
    } finally {
      if (missing != null) {
        missing.close();
      }
    }

    extrasLabel.setText("Extras not found: " + notFound.size() + "/" + list.size());

    out.println("Extras not found: " + notFound.size() + "/" + list.size());
    for (final Extra extra : notFound) {
      out.println("   " + extra.getFilename() + "  (" + extra.getName() + ")");
    }

    progressBar.setIndeterminate(true);
    progressLabel.setText("Writing to database...");
    Db.saveOrUpdateAll(list);
    Db.saveOrUpdateAll(gameList);

    // clean up
    progressBar.setIndeterminate(false);
    progressLabel.setText(" ");
    progressBar.setMinimum(0);
    progressBar.setValue(0);
  }

  private void exitFormWindowClosing(final java.awt.event.WindowEvent evt) {// GEN-FIRST:event_exitFormWindowClosing
    cancel();
  }// GEN-LAST:event_exitFormWindowClosing
}
